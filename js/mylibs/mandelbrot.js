// Generated by CoffeeScript 1.3.1
(function() {
  var Mandelbrot,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Mandelbrot = (function() {
    var drawEscapeTimes, drawSetInMainThread, drawSetWithWorker, generateColorScheme, getColor, setCanvasSize, setPixel,
      _this = this;

    function Mandelbrot(colorConverter) {
      this.colorConverter = colorConverter;
      this.run = __bind(this.run, this);

      if (!((this.colorConverter != null) && (this.colorConverter.colorToRgb != null))) {
        throw "Cannot construct a Mandelbrot without a colorConverter that imlements colorToRgb({h:,s:,v:}).";
      }
      this.box = {
        top: 1,
        left: -2,
        bottom: -1,
        right: 1
      };
      this.maxIterations = 30;
      if (window.Modernizr.webworkers && window.JSON) {
        this.worker = new window.Worker('../../js/mylibs/mandelbrot-worker.js');
        this.drawSet = function(context, maxIterations) {
          return drawSetWithWorker(this.worker, context, this.box, maxIterations, this.colorConverter);
        };
      } else {
        this.drawSet = this.drawSetInMainThread;
      }
    }

    Mandelbrot.prototype.run = function(canvasId) {
      var canvasElement, context, mi,
        _this = this;
      canvasElement = document.getElementById(canvasId);
      if (canvasElement == null) {
        throw 'Could not find canvas element ' + canvasId;
      }
      context = canvasElement.getContext('2d');
      if (context == null) {
        throw 'Could not build 2d canvas context in ' + canvasId;
      }
      setCanvasSize(canvasId, context);
      this.drawSet(context, this.maxIterations);
      mi = $('#maxIterationsButton').click(function() {
        _this.maxIterations = $('#maxIterations').val();
        if (_this.worker != null) {
          _this.worker.terminate();
          _this.worker = new window.Worker('../../js/mylibs/mandelbrot-worker.js');
        }
        $('#mandelbrotProgress').find('.bar').width('0%');
        $('#mandelbrotProgress').addClass('progress-striped');
        $('#mandelbrotProgress').addClass('active');
        $('#mandelbrotProgress').removeClass('progress-success');
        _this.drawSet(context, _this.maxIterations);
        return false;
      });
      return $(window).resize(function() {
        var resizeTimer;
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout((function() {
          return setCanvasSize(canvasId, context);
        }), 100);
        return 0;
      });
    };

    drawSetWithWorker = function(worker, context, box, maxIterations, colorConverter) {
      var height, message, width;
      width = context.canvas.width;
      height = context.canvas.height;
      message = JSON.stringify({
        message: "run",
        width: width,
        height: height,
        box: {
          top: box.top,
          left: box.left,
          bottom: box.bottom,
          right: box.right
        },
        maxIterations: Mandelbrot.maxIterations
      });
      worker.addEventListener('message', (function(e) {
        var data;
        data = JSON.parse(e.data);
        switch (data.message) {
          case "progress":
            return $('#mandelbrotProgress .bar').css('width', data.value + '%');
          case "success":
            drawEscapeTimes(context, data.value, maxIterations, colorConverter);
            $('#mandelbrotProgress').removeClass('progress-striped');
            $('#mandelbrotProgress').removeClass('active');
            return $('#mandelbrotProgress').addClass('progress-success');
          default:
            return window.alert("Unrecognised message from worker");
        }
      }), false);
      return worker.postMessage(message);
    };

    drawSetInMainThread = function(context) {
      return 0;
    };

    drawEscapeTimes = function(context, escapeTimes, maxIterations, colorConverter) {
      var colorScheme, height, imageData, row, settings, width, _fn, _i;
      colorScheme = generateColorScheme(function(i) {
        return colorConverter.colorToRgb({
          h: 360 * i / 255,
          s: 1,
          v: 1
        });
      });
      settings = {
        isBinary: false,
        maxIterations: maxIterations,
        insideSetColor: {
          r: 0,
          g: 0,
          b: 0
        },
        colorScheme: colorScheme
      };
      width = context.canvas.width;
      height = context.canvas.height;
      imageData = context.createImageData(width, height);
      _fn = function(row) {
        var column, _fn1, _j;
        _fn1 = function(column) {
          var color;
          color = getColor(escapeTimes[row][column], settings);
          setPixel(imageData, column, row, color.r, color.g, color.b, 255);
          return 0;
        };
        for (column = _j = 0; 0 <= width ? _j <= width : _j >= width; column = 0 <= width ? ++_j : --_j) {
          _fn1(column);
        }
        return 0;
      };
      for (row = _i = 0; 0 <= height ? _i <= height : _i >= height; row = 0 <= height ? ++_i : --_i) {
        _fn(row);
      }
      return context.putImageData(imageData, 0, 0);
    };

    getColor = function(escapeTime, settings) {
      var color, maxIterations;
      maxIterations = settings.maxIterations;
      if (escapeTime >= maxIterations) {
        return {
          r: settings.insideSetColor.r,
          g: settings.insideSetColor.g,
          b: settings.insideSetColor.b
        };
      } else {
        if (settings.isBinary) {
          color = settings.colorScheme[0];
        } else {
          color = settings.colorScheme[Math.floor(255 * (escapeTime / maxIterations))];
        }
        return {
          r: color.r,
          g: color.g,
          b: color.b
        };
      }
    };

    generateColorScheme = function(func) {
      var i, _i, _results;
      _results = [];
      for (i = _i = 0; _i <= 255; i = ++_i) {
        _results.push(func(i));
      }
      return _results;
    };

    setPixel = function(imageData, x, y, r, g, b, a) {
      var index;
      index = (x + y * imageData.width) * 4;
      imageData.data[index + 0] = r;
      imageData.data[index + 1] = g;
      imageData.data[index + 2] = b;
      return imageData.data[index + 3] = a;
    };

    setCanvasSize = function(canvasId, context) {
      var width;
      width = $('#' + canvasId).parent().width();
      context.canvas.width = width;
      context.canvas.height = width * 2 / 3.0;
      return 0;
    };

    return Mandelbrot;

  }).call(this);

  window.Mandelbrot = Mandelbrot;

}).call(this);
